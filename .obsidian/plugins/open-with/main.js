/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');
var path = require('path');
var childProcess = require('child_process');
var fs$1 = require('fs');
var os = require('os');
var electron = require('electron');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var childProcess__default = /*#__PURE__*/_interopDefaultLegacy(childProcess);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs$1);
var os__default = /*#__PURE__*/_interopDefaultLegacy(os);

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

let isDocker;

function hasDockerEnv() {
	try {
		fs__default["default"].statSync('/.dockerenv');
		return true;
	} catch (_) {
		return false;
	}
}

function hasDockerCGroup() {
	try {
		return fs__default["default"].readFileSync('/proc/self/cgroup', 'utf8').includes('docker');
	} catch (_) {
		return false;
	}
}

var isDocker_1 = () => {
	if (isDocker === undefined) {
		isDocker = hasDockerEnv() || hasDockerCGroup();
	}

	return isDocker;
};

var isWsl_1 = createCommonjsModule(function (module) {




const isWsl = () => {
	if (process.platform !== 'linux') {
		return false;
	}

	if (os__default["default"].release().toLowerCase().includes('microsoft')) {
		if (isDocker_1()) {
			return false;
		}

		return true;
	}

	try {
		return fs__default["default"].readFileSync('/proc/version', 'utf8').toLowerCase().includes('microsoft') ?
			!isDocker_1() : false;
	} catch (_) {
		return false;
	}
};

if (process.env.__IS_WSL_TEST__) {
	module.exports = isWsl;
} else {
	module.exports = isWsl();
}
});

var defineLazyProp = (object, propertyName, fn) => {
	const define = value => Object.defineProperty(object, propertyName, {value, enumerable: true, writable: true});

	Object.defineProperty(object, propertyName, {
		configurable: true,
		enumerable: true,
		get() {
			const result = fn();
			define(result);
			return result;
		},
		set(value) {
			define(value);
		}
	});

	return object;
};

const {promises: fs, constants: fsConstants} = fs__default["default"];




// Path to included `xdg-open`.
const localXdgOpenPath = path__default["default"].join(__dirname, 'xdg-open');

const {platform, arch} = process;

// Podman detection
const hasContainerEnv = () => {
	try {
		fs.statSync('/run/.containerenv');
		return true;
	} catch {
		return false;
	}
};

let cachedResult;
function isInsideContainer() {
	if (cachedResult === undefined) {
		cachedResult = hasContainerEnv() || isDocker_1();
	}

	return cachedResult;
}

/**
Get the mount point for fixed drives in WSL.

@inner
@returns {string} The mount point.
*/
const getWslDrivesMountPoint = (() => {
	// Default value for "root" param
	// according to https://docs.microsoft.com/en-us/windows/wsl/wsl-config
	const defaultMountPoint = '/mnt/';

	let mountPoint;

	return async function () {
		if (mountPoint) {
			// Return memoized mount point value
			return mountPoint;
		}

		const configFilePath = '/etc/wsl.conf';

		let isConfigFileExists = false;
		try {
			await fs.access(configFilePath, fsConstants.F_OK);
			isConfigFileExists = true;
		} catch {}

		if (!isConfigFileExists) {
			return defaultMountPoint;
		}

		const configContent = await fs.readFile(configFilePath, {encoding: 'utf8'});
		const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);

		if (!configMountPoint) {
			return defaultMountPoint;
		}

		mountPoint = configMountPoint.groups.mountPoint.trim();
		mountPoint = mountPoint.endsWith('/') ? mountPoint : `${mountPoint}/`;

		return mountPoint;
	};
})();

const pTryEach = async (array, mapper) => {
	let latestError;

	for (const item of array) {
		try {
			return await mapper(item); // eslint-disable-line no-await-in-loop
		} catch (error) {
			latestError = error;
		}
	}

	throw latestError;
};

const baseOpen = async options => {
	options = {
		wait: false,
		background: false,
		newInstance: false,
		allowNonzeroExitCode: false,
		...options
	};

	if (Array.isArray(options.app)) {
		return pTryEach(options.app, singleApp => baseOpen({
			...options,
			app: singleApp
		}));
	}

	let {name: app, arguments: appArguments = []} = options.app || {};
	appArguments = [...appArguments];

	if (Array.isArray(app)) {
		return pTryEach(app, appName => baseOpen({
			...options,
			app: {
				name: appName,
				arguments: appArguments
			}
		}));
	}

	let command;
	const cliArguments = [];
	const childProcessOptions = {};

	if (platform === 'darwin') {
		command = 'open';

		if (options.wait) {
			cliArguments.push('--wait-apps');
		}

		if (options.background) {
			cliArguments.push('--background');
		}

		if (options.newInstance) {
			cliArguments.push('--new');
		}

		if (app) {
			cliArguments.push('-a', app);
		}
	} else if (platform === 'win32' || (isWsl_1 && !isInsideContainer() && !app)) {
		const mountPoint = await getWslDrivesMountPoint();

		command = isWsl_1 ?
			`${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` :
			`${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;

		cliArguments.push(
			'-NoProfile',
			'-NonInteractive',
			'â€“ExecutionPolicy',
			'Bypass',
			'-EncodedCommand'
		);

		if (!isWsl_1) {
			childProcessOptions.windowsVerbatimArguments = true;
		}

		const encodedArguments = ['Start'];

		if (options.wait) {
			encodedArguments.push('-Wait');
		}

		if (app) {
			// Double quote with double quotes to ensure the inner quotes are passed through.
			// Inner quotes are delimited for PowerShell interpretation with backticks.
			encodedArguments.push(`"\`"${app}\`""`, '-ArgumentList');
			if (options.target) {
				appArguments.unshift(options.target);
			}
		} else if (options.target) {
			encodedArguments.push(`"${options.target}"`);
		}

		if (appArguments.length > 0) {
			appArguments = appArguments.map(arg => `"\`"${arg}\`""`);
			encodedArguments.push(appArguments.join(','));
		}

		// Using Base64-encoded command, accepted by PowerShell, to allow special characters.
		options.target = Buffer.from(encodedArguments.join(' '), 'utf16le').toString('base64');
	} else {
		if (app) {
			command = app;
		} else {
			// When bundled by Webpack, there's no actual package file path and no local `xdg-open`.
			const isBundled = !__dirname || __dirname === '/';

			// Check if local `xdg-open` exists and is executable.
			let exeLocalXdgOpen = false;
			try {
				await fs.access(localXdgOpenPath, fsConstants.X_OK);
				exeLocalXdgOpen = true;
			} catch {}

			const useSystemXdgOpen = process.versions.electron ||
				platform === 'android' || isBundled || !exeLocalXdgOpen;
			command = useSystemXdgOpen ? 'xdg-open' : localXdgOpenPath;
		}

		if (appArguments.length > 0) {
			cliArguments.push(...appArguments);
		}

		if (!options.wait) {
			// `xdg-open` will block the process unless stdio is ignored
			// and it's detached from the parent even if it's unref'd.
			childProcessOptions.stdio = 'ignore';
			childProcessOptions.detached = true;
		}
	}

	if (options.target) {
		cliArguments.push(options.target);
	}

	if (platform === 'darwin' && appArguments.length > 0) {
		cliArguments.push('--args', ...appArguments);
	}

	const subprocess = childProcess__default["default"].spawn(command, cliArguments, childProcessOptions);

	if (options.wait) {
		return new Promise((resolve, reject) => {
			subprocess.once('error', reject);

			subprocess.once('close', exitCode => {
				if (!options.allowNonzeroExitCode && exitCode > 0) {
					reject(new Error(`Exited with code ${exitCode}`));
					return;
				}

				resolve(subprocess);
			});
		});
	}

	subprocess.unref();

	return subprocess;
};

const open = (target, options) => {
	if (typeof target !== 'string') {
		throw new TypeError('Expected a `target`');
	}

	return baseOpen({
		...options,
		target
	});
};

const openApp = (name, options) => {
	if (typeof name !== 'string') {
		throw new TypeError('Expected a `name`');
	}

	const {arguments: appArguments = []} = options || {};
	if (appArguments !== undefined && appArguments !== null && !Array.isArray(appArguments)) {
		throw new TypeError('Expected `appArguments` as Array type');
	}

	return baseOpen({
		...options,
		app: {
			name,
			arguments: appArguments
		}
	});
};

function detectArchBinary(binary) {
	if (typeof binary === 'string' || Array.isArray(binary)) {
		return binary;
	}

	const {[arch]: archBinary} = binary;

	if (!archBinary) {
		throw new Error(`${arch} is not supported`);
	}

	return archBinary;
}

function detectPlatformBinary({[platform]: platformBinary}, {wsl}) {
	if (wsl && isWsl_1) {
		return detectArchBinary(wsl);
	}

	if (!platformBinary) {
		throw new Error(`${platform} is not supported`);
	}

	return detectArchBinary(platformBinary);
}

const apps = {};

defineLazyProp(apps, 'chrome', () => detectPlatformBinary({
	darwin: 'google chrome',
	win32: 'chrome',
	linux: ['google-chrome', 'google-chrome-stable', 'chromium']
}, {
	wsl: {
		ia32: '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe',
		x64: ['/mnt/c/Program Files/Google/Chrome/Application/chrome.exe', '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe']
	}
}));

defineLazyProp(apps, 'firefox', () => detectPlatformBinary({
	darwin: 'firefox',
	win32: 'C:\\Program Files\\Mozilla Firefox\\firefox.exe',
	linux: 'firefox'
}, {
	wsl: '/mnt/c/Program Files/Mozilla Firefox/firefox.exe'
}));

defineLazyProp(apps, 'edge', () => detectPlatformBinary({
	darwin: 'microsoft edge',
	win32: 'msedge',
	linux: ['microsoft-edge', 'microsoft-edge-dev']
}, {
	wsl: '/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe'
}));

open.apps = apps;
open.openApp = openApp;

var open_1 = open;

const DEFAULT_SETTINGS = {
    apps: [],
    sysexpInFileMenu: false,
};
class OpenWithPlugin extends obsidian.Plugin {
    constructor() {
        super(...arguments);
        this.fileMenuHandlerCreateNew = (menu, file) => {
            this.settings.apps.forEach(app => {
                if (app.showInMenu) {
                    menu.addItem(item => {
                        item
                            .setTitle(`Open with ${app.name}`)
                            .setIcon('popup-open')
                            .onClick(() => open_1(this.getAbsolutePathOfFile(file), {
                            app: {
                                name: app.code,
                                arguments: app.arguments.split(","),
                            }
                        }));
                    });
                }
            });
            if (this.settings.sysexpInFileMenu) {
                menu.addItem(item => {
                    item
                        .setTitle('Show in system explorer')
                        .setIcon('popup-open')
                        .onClick(() => electron.shell.showItemInFolder(this.getAbsolutePathOfFile(file)));
                });
            }
        };
    }
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('loading plugin');
            yield this.loadSettings();
            this.addSettingTab(new OpenWithSettingTab(this));
            this.addCommand({
                id: "copy-absolute-file-path",
                name: "Copy absolute Path of File to clipboard",
                checkCallback: (checking) => {
                    let file = this.app.workspace.getActiveFile();
                    if (file) {
                        if (!checking) {
                            navigator.clipboard.writeText(this.getAbsolutePathOfFile(file));
                        }
                        return true;
                    }
                    return false;
                }
            });
            this.addCommand({
                id: 'show-file-in-explorer',
                name: 'Show File in system explorer',
                checkCallback: (checking) => {
                    let file = this.app.workspace.getActiveFile();
                    if (file) {
                        if (!checking) {
                            electron.shell.showItemInFolder(this.getAbsolutePathOfFile(file));
                        }
                        return true;
                    }
                    return false;
                }
            });
            this.settings.apps.forEach(app => {
                this.addCommand({
                    id: "open-file-with-" + app.name.toLowerCase(),
                    name: "Open File with " + app.name,
                    checkCallback: (checking) => {
                        let file = this.app.workspace.getActiveFile();
                        if (file) {
                            if (!checking) {
                                open_1(this.getAbsolutePathOfFile(file), {
                                    app: {
                                        name: app.code,
                                        arguments: app.arguments.split(","),
                                    }
                                });
                            }
                            return true;
                        }
                        return false;
                    }
                });
            });
            this.registerEvent(this.app.workspace.on("file-menu", this.fileMenuHandlerCreateNew));
        });
    }
    getAbsolutePathOfFile(file) {
        //@ts-ignore
        const path$1 = path.normalize(`${this.app.vault.adapter.basePath}/${file.path}`);
        if (obsidian.Platform.isDesktopApp && navigator.platform === "Win32") {
            return path$1.replace(/\//g, "\\");
        }
        return path$1;
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
}
class OpenWithSettingTab extends obsidian.PluginSettingTab {
    constructor(plugin) {
        super(plugin.app, plugin);
        this.plugin = plugin;
    }
    display() {
        let { containerEl } = this;
        containerEl.empty();
        containerEl.addClass('OW-settings-page');
        containerEl.createEl('h2', { text: 'Open with Plugin' });
        new obsidian.Setting(containerEl)
            .setName("Add new application")
            .setClass("OW-setting-item")
            .setDesc("Add a new application to open files with. You need to use the application path or command (for example \"code\" for VSCode) and arguments need to be comma seperated.")
            .addText(cb => {
            cb.inputEl.addClass("OW-name");
            cb.setPlaceholder("Display Name");
        })
            .addText(cb => {
            cb.inputEl.addClass("OW-code");
            cb.setPlaceholder("Path/Command");
        })
            .addText(cb => {
            cb.inputEl.addClass("OW-args");
            cb.setPlaceholder("Arguments (optional)");
        })
            .addButton(btn => {
            btn.setButtonText("+")
                .onClick(() => __awaiter(this, void 0, void 0, function* () {
                //@ts-ignore
                const name = document.querySelector(".OW-name").value;
                //@ts-ignore
                const code = document.querySelector(".OW-code").value;
                //@ts-ignore
                const args = document.querySelector(".OW-args").value;
                if (name && code) {
                    this.plugin.addCommand({
                        id: "open-file-with-" + name.toLowerCase(),
                        name: "Open File with " + name,
                        checkCallback: (checking) => {
                            let file = this.app.workspace.getActiveFile();
                            if (file) {
                                if (!checking) {
                                    open_1(this.plugin.getAbsolutePathOfFile(file), {
                                        app: {
                                            name: code,
                                            arguments: args.split(","),
                                        }
                                    });
                                }
                                return true;
                            }
                            return false;
                        }
                    });
                    this.plugin.settings.apps.push({ name, code, arguments: args, showInMenu: false });
                    yield this.plugin.saveSettings();
                    this.display();
                }
                else {
                    new obsidian.Notice("Display Name & Path/Command are always neccessary.");
                }
            }));
        });
        this.plugin.settings.apps.forEach(app => {
            new obsidian.Setting(containerEl)
                .setName(app.name)
                .setDesc(`Command: ${app.code}${app.arguments ? ` | Arguments: ${app.arguments}` : ""}`)
                .addToggle(cb => {
                cb.toggleEl.parentElement.prepend('Show in File-Menu ');
                cb.setValue(app.showInMenu).onChange((value) => __awaiter(this, void 0, void 0, function* () {
                    app.showInMenu = value;
                    yield this.plugin.saveSettings();
                }));
            })
                .addButton(btn => {
                btn.setIcon("trash")
                    .setTooltip("Remove")
                    .onClick(() => __awaiter(this, void 0, void 0, function* () {
                    new obsidian.Notice("You need to restart Obsidian for these changes to take effect.");
                    this.plugin.settings.apps.remove(app);
                    yield this.plugin.saveSettings();
                    this.display();
                }));
            });
        });
        new obsidian.Setting(containerEl)
            .setName('Show "Show in system explorer" in File-Menu')
            .setDesc('Show the enhanced "Show in system explorer" command in File-Menus')
            .addToggle(cb => {
            cb.setValue(this.plugin.settings.sysexpInFileMenu).onChange((value) => __awaiter(this, void 0, void 0, function* () {
                this.plugin.settings.sysexpInFileMenu = value;
                yield this.plugin.saveSettings();
            }));
        });
    }
}

module.exports = OpenWithPlugin;


/* nosourcemap */